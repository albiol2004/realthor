import { createClient } from '@/lib/supabase/server'
import type {
  SemanticSearchParams,
  SemanticSearchResult,
  Document,
} from '@/types/crm'
import { TRPCError } from '@trpc/server'

/**
 * Semantic Search Service
 * Handles vector-based document search using embeddings
 *
 * NOTE: This service requires embeddings to be generated first.
 * Embeddings are generated by the VPS OCR Service after OCR processing.
 */
export class SemanticSearchService {
  /**
   * Search documents using semantic similarity
   *
   * This performs a vector similarity search using the embeddings stored
   * in the document_embeddings table. The search uses cosine distance
   * with an HNSW index for blazing fast performance (<50ms).
   *
   * @param userId - User ID to filter results
   * @param params - Search parameters (query, filters, limits)
   * @returns Array of search results with similarity scores
   */
  async searchDocuments(
    userId: string,
    params: SemanticSearchParams
  ): Promise<SemanticSearchResult[]> {
    const {
      query,
      threshold = 0.6, // Default: 60% similarity minimum
      limit = 20,
      entityType,
      category,
    } = params

    // Step 1: Generate embedding for the search query
    // NOTE: In production, this should call your VPS embeddings service
    // For MVP, we'll use a placeholder that returns mock embeddings
    const queryEmbedding = await this.generateQueryEmbedding(query)

    // Step 2: Call the database function for semantic search
    const supabase = await createClient()

    const { data, error } = await supabase.rpc('search_documents_by_embedding', {
      query_embedding: queryEmbedding,
      user_id_param: userId,
      match_threshold: threshold,
      match_count: limit,
    })

    if (error) {
      console.error('Semantic search error:', error)
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Failed to perform semantic search',
      })
    }

    // Step 3: Apply additional filters if provided
    let results = data || []

    if (entityType) {
      // Note: This requires joining with documents table in the SQL function
      // For now, we'll filter client-side
      results = results.filter((r: any) => {
        // This is a placeholder - implement based on your needs
        return true
      })
    }

    if (category) {
      results = results.filter((r: any) => r.category === category)
    }

    // Step 4: Map to TypeScript types
    return results.map((row: any) => ({
      documentId: row.document_id,
      filename: row.filename,
      fileUrl: row.file_url,
      category: row.category,
      similarity: parseFloat(row.similarity),
      chunkText: row.chunk_text,
      chunkIndex: row.chunk_index,
    }))
  }

  /**
   * Search documents with full document details
   *
   * Same as searchDocuments but includes full document object
   */
  async searchDocumentsWithDetails(
    userId: string,
    params: SemanticSearchParams
  ): Promise<SemanticSearchResult[]> {
    const results = await this.searchDocuments(userId, params)

    // Fetch full document details for each result
    const supabase = await createClient()

    const documentIds = [...new Set(results.map((r) => r.documentId))]

    const { data: documents, error } = await supabase
      .from('documents')
      .select('*')
      .in('id', documentIds)
      .eq('user_id', userId)

    if (error) {
      console.error('Failed to fetch document details:', error)
      // Return results without full document details
      return results
    }

    // Map documents by ID for quick lookup
    const documentsMap = new Map<string, Document>()
    documents?.forEach((doc) => {
      documentsMap.set(doc.id, this.mapToDocument(doc))
    })

    // Attach document details to results
    return results.map((result) => ({
      ...result,
      document: documentsMap.get(result.documentId),
    }))
  }

  /**
   * Find similar documents to a given document
   *
   * Useful for "documents like this" recommendations
   */
  async findSimilarDocuments(
    userId: string,
    documentId: string,
    limit: number = 10
  ): Promise<SemanticSearchResult[]> {
    const supabase = await createClient()

    // Get the first embedding for the document
    const { data: embeddingData, error: embeddingError } = await supabase
      .from('document_embeddings')
      .select('embedding, chunk_text')
      .eq('document_id', documentId)
      .eq('user_id', userId)
      .eq('chunk_index', 0) // Use first chunk as representative
      .single()

    if (embeddingError || !embeddingData) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Document embeddings not found',
      })
    }

    // Search using the document's embedding
    const { data, error } = await supabase.rpc('search_documents_by_embedding', {
      query_embedding: embeddingData.embedding,
      user_id_param: userId,
      match_threshold: 0.7, // Higher threshold for similarity
      match_count: limit + 1, // +1 because it will include itself
    })

    if (error) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Failed to find similar documents',
      })
    }

    // Filter out the original document
    const results = (data || [])
      .filter((row: any) => row.document_id !== documentId)
      .slice(0, limit)

    return results.map((row: any) => ({
      documentId: row.document_id,
      filename: row.filename,
      fileUrl: row.file_url,
      category: row.category,
      similarity: parseFloat(row.similarity),
      chunkText: row.chunk_text,
      chunkIndex: row.chunk_index,
    }))
  }

  /**
   * Generate embedding for search query
   *
   * TODO: Replace with actual VPS embeddings service call
   *
   * In production, this should:
   * 1. Call your VPS API: POST /api/embeddings/generate
   * 2. Receive 384-dimensional vector
   * 3. Return the vector
   *
   * For MVP, returns a placeholder array
   */
  private async generateQueryEmbedding(query: string): Promise<number[]> {
    // PLACEHOLDER: Replace with actual embeddings API call
    // Example implementation:
    //
    // const response = await fetch('http://your-vps:8000/api/embeddings/generate', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify({ text: query })
    // })
    // const data = await response.json()
    // return data.embedding

    // For now, return a random 384-dimensional vector
    // THIS WILL NOT WORK FOR REAL SEARCHES - EMBEDDINGS MUST BE GENERATED PROPERLY
    console.warn(
      '⚠️ Using placeholder embeddings! Replace with VPS embeddings service.'
    )

    return Array(384)
      .fill(0)
      .map(() => Math.random() * 2 - 1)
  }

  /**
   * Map database row to Document type
   */
  private mapToDocument(row: any): Document {
    return {
      id: row.id,
      userId: row.user_id,
      filename: row.filename,
      fileUrl: row.file_url,
      fileSize: row.file_size,
      fileType: row.file_type,
      entityType: row.entity_type,
      entityId: row.entity_id,
      documentType: row.category,
      documentDate: row.document_date ? new Date(row.document_date) : undefined,
      dueDate: row.due_date ? new Date(row.due_date) : undefined,
      tags: row.tags || [],
      description: row.description,
      uploadedBy: row.uploaded_by,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      ocrText: row.ocr_text,
      ocrStatus: row.ocr_status || 'pending',
      ocrProcessedAt: row.ocr_processed_at ? new Date(row.ocr_processed_at) : undefined,
      aiMetadata: row.ai_metadata,
      aiConfidence: row.ai_confidence,
      aiProcessedAt: row.ai_processed_at ? new Date(row.ai_processed_at) : undefined,
      hasSignature: row.has_signature || false,
      signatureStatus: row.signature_status,
      importanceScore: row.importance_score,
      extractedNames: row.extracted_names || [],
      extractedDates: (row.extracted_dates || []).map((d: string) => new Date(d)),
      relatedContactIds: row.related_contact_ids || [],
      relatedPropertyIds: row.related_property_ids || [],
    }
  }
}

export const semanticSearchService = new SemanticSearchService()
